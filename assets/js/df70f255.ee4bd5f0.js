"use strict";(self.webpackChunkcrypto_tracker=self.webpackChunkcrypto_tracker||[]).push([[242],{331:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>l,default:()=>h,frontMatter:()=>a,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"challenges-solutions","title":"Challenges & Solutions","description":"This document outlines the key challenges encountered during the development of CryptoTrackPro and the solutions implemented.","source":"@site/docs/challenges-solutions.md","sourceDirName":".","slug":"/challenges-solutions","permalink":"/CryptoTrackPro/docs/challenges-solutions","draft":false,"unlisted":false,"editUrl":"https://github.com/your-github-user/crypto-tracker/edit/main/docs-site/docs/challenges-solutions.md","tags":[],"version":"current","frontMatter":{"id":"challenges-solutions","title":"Challenges & Solutions","sidebar_label":"Challenges & Solutions"},"sidebar":"Sidebar","previous":{"title":"Authentication (Optional)","permalink":"/CryptoTrackPro/docs/authentication"},"next":{"title":"Best Practices","permalink":"/CryptoTrackPro/docs/best-practices"}}');var s=t(4848),r=t(8453);const a={id:"challenges-solutions",title:"Challenges & Solutions",sidebar_label:"Challenges & Solutions"},l="Challenges & Solutions",o={},c=[{value:"Challenge 1: Real-time Data Updates",id:"challenge-1-real-time-data-updates",level:2},{value:"Challenge 2: Authentication System",id:"challenge-2-authentication-system",level:2},{value:"Challenge 3: Responsive UI Design",id:"challenge-3-responsive-ui-design",level:2},{value:"Challenge 4: Search and Pagination",id:"challenge-4-search-and-pagination",level:2},{value:"Best Practices and Learnings",id:"best-practices-and-learnings",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"challenges--solutions",children:"Challenges & Solutions"})}),"\n",(0,s.jsx)(n.p,{children:"This document outlines the key challenges encountered during the development of CryptoTrackPro and the solutions implemented."}),"\n",(0,s.jsx)(n.h2,{id:"challenge-1-real-time-data-updates",children:"Challenge 1: Real-time Data Updates"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Implementing real-time cryptocurrency price updates without overwhelming the API or causing excessive re-renders."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Used React Query with a reasonable polling interval (3 seconds) as a balance between freshness and performance"}),"\n",(0,s.jsx)(n.li,{children:"Implemented visual indicators to highlight price changes"}),"\n",(0,s.jsx)(n.li,{children:"Created a debounce mechanism for price change animations to prevent visual overload"}),"\n",(0,s.jsx)(n.li,{children:"Added price change tracking to only update specific components"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// From app/dashboard/page.tsx\n// Price change tracking with useEffect\nuseEffect(() => {\n  if (data?.data) {\n    const newChanges: string[] = [];\n    const newPulseMap: Record<string, 'increase' | 'decrease' | null> = {};\n    \n    // Check for price changes and determine direction\n    data.data.forEach((crypto: Cryptocurrency) => {\n      const prevPrice = previousPrices[crypto.id];\n      \n      if (prevPrice !== undefined) {\n        const currentPrice = parseFloat(crypto.priceUsd);\n        const previousPrice = parseFloat(prevPrice);\n        \n        // Only detect significant changes to avoid floating point issues\n        if (Math.abs(currentPrice - previousPrice) > 0.0000001) {\n          newChanges.push(crypto.id);\n          newPulseMap[crypto.id] = currentPrice > previousPrice ? 'increase' : 'decrease';\n        }\n      }\n    });\n    \n    // Update previous prices for next comparison\n    const newPrices: Record<string, string> = {};\n    data.data.forEach((crypto: Cryptocurrency) => {\n      newPrices[crypto.id] = crypto.priceUsd;\n    });\n    \n    setPreviousPrices(newPrices);\n    setPricePulseMap(newPulseMap);\n    \n    // Properly update the changedCryptos list\n    if (newChanges.length > 0) {\n      setChangedCryptos(prev => {\n        // Remove any IDs from prev that are also in newChanges\n        const filteredPrev = prev.filter(id => !newChanges.includes(id));\n        // Add new changes at the beginning, keep only 5 in total\n        return [...newChanges, ...filteredPrev].slice(0, 5);\n      });\n    }\n    \n    // Reset pulse effects after animation duration\n    const timer = setTimeout(() => {\n      setPricePulseMap({});\n    }, 3000); // 3 seconds [same as CSS animation duration in global.css]\n    \n    return () => clearTimeout(timer);\n  }\n}, [data]);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"challenge-2-authentication-system",children:"Challenge 2: Authentication System"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Implementing a secure, persistent authentication system with JWT."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Created a custom JWT-based authentication system"}),"\n",(0,s.jsx)(n.li,{children:"Used HTTP-only cookies for secure token storage"}),"\n",(0,s.jsx)(n.li,{children:"Implemented token verification on both client and server"}),"\n",(0,s.jsx)(n.li,{children:"Added route protection with Next.js middleware"}),"\n",(0,s.jsx)(n.li,{children:"Used Zustand with persist middleware for auth state management"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// JWT verification function\nexport async function verifyToken(token: string) {\n  try {\n    const { payload } = await jwtVerify(token, secret);\n    return payload;\n  } catch (error) {\n    console.error('Error verifying token:', error);\n    return null;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"challenge-3-responsive-ui-design",children:"Challenge 3: Responsive UI Design"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Creating a responsive UI that works well on both desktop and mobile devices."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Used Tailwind CSS for responsive design"}),"\n",(0,s.jsx)(n.li,{children:"Implemented shadcn/ui components for consistent styling"}),"\n",(0,s.jsx)(n.li,{children:"Created a responsive card grid that adapts to screen size"}),"\n",(0,s.jsx)(n.li,{children:"Added mobile-friendly navigation"}),"\n",(0,s.jsx)(n.li,{children:"Used CSS Grid and Flexbox for layout management"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Responsive card grid example\n<div className="mt-4 grid grid-cols-2 gap-4 md:grid-cols-5">\n  {topCryptos.map((crypto) => (\n    <CryptoCard \n      key={crypto.id} \n      crypto={crypto} \n      previousPrice={previousPrices[crypto.id]} \n      isRecent={changedCryptos.includes(crypto.id)}\n      pulseDirection={pricePulseMap[crypto.id]}\n    />\n  ))}\n</div>\n'})}),"\n",(0,s.jsx)(n.h2,{id:"challenge-4-search-and-pagination",children:"Challenge 4: Search and Pagination"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Challenge"}),": Implementing efficient search and pagination for potentially large datasets."]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Solution"}),":"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Added debounced search to prevent excessive filtering"}),"\n",(0,s.jsx)(n.li,{children:"Implemented client-side pagination for better UX"}),"\n",(0,s.jsx)(n.li,{children:"Optimized filtering logic to maintain performance"}),"\n",(0,s.jsx)(n.li,{children:"Reset page when search term changes"}),"\n",(0,s.jsx)(n.li,{children:"Added clear visual indicators for search and loading states"}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Debounce hook for search\nconst debouncedSearchTerm = useDebounce(searchTerm, 500);\n\n// Search implementation\nconst filteredData = allCryptos.filter(crypto =>\n  debouncedSearchTerm === '' || \n  crypto.name.toLowerCase().includes(debouncedSearchTerm.toLowerCase()) ||\n  crypto.symbol.toLowerCase().includes(debouncedSearchTerm.toLowerCase())\n);\n\n// Pagination logic\nconst totalPages = Math.ceil(filteredData.length / itemsPerPage);\nconst paginatedCryptos = filteredData.slice((page - 1) * itemsPerPage, page * itemsPerPage);\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-and-learnings",children:"Best Practices and Learnings"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Type Safety"}),": Using TypeScript throughout the project improved code quality and reduced bugs"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Component Reusability"}),": Creating reusable components reduced duplication and improved maintainability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"API Rate Limiting"}),": Implementing proper polling intervals to respect API limits"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Error Handling"}),": Adding comprehensive error handling improved user experience"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"State Management"}),": Choosing the right state management tools for different parts of the application"]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>l});var i=t(6540);const s={},r=i.createContext(s);function a(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);