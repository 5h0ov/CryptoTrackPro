"use strict";(self.webpackChunkcrypto_tracker=self.webpackChunkcrypto_tracker||[]).push([[1831],{3341:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"authentication","title":"Authentication (Optional)","description":"This document explains the addition of the authentication system implemented in CryptoTrackPro.","source":"@site/docs/authentication.md","sourceDirName":".","slug":"/authentication","permalink":"/CryptoTrackPro/docs/authentication","draft":false,"unlisted":false,"editUrl":"https://github.com/your-github-user/crypto-tracker/edit/main/docs-site/docs/authentication.md","tags":[],"version":"current","frontMatter":{"id":"authentication","title":"Authentication (Optional)","sidebar_label":"Authentication (Optional)"},"sidebar":"Sidebar","previous":{"title":"State Management","permalink":"/CryptoTrackPro/docs/state-management"},"next":{"title":"Challenges & Solutions","permalink":"/CryptoTrackPro/docs/challenges-solutions"}}');var i=t(4848),r=t(8453);const o={id:"authentication",title:"Authentication (Optional)",sidebar_label:"Authentication (Optional)"},a="Authentication (Optional)",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Authentication Flow",id:"authentication-flow",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Backend Routes",id:"backend-routes",level:3},{value:"Register Endpoint",id:"register-endpoint",level:4},{value:"Login Endpoint",id:"login-endpoint",level:4},{value:"Check Auth Endpoint",id:"check-auth-endpoint",level:4},{value:"Frontend State Management",id:"frontend-state-management",level:3},{value:"Route Protection",id:"route-protection",level:2},{value:"Security Considerations",id:"security-considerations",level:2}];function d(e){const n={code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"authentication-optional",children:"Authentication (Optional)"})}),"\n",(0,i.jsx)(n.p,{children:"This document explains the addition of the authentication system implemented in CryptoTrackPro."}),"\n",(0,i.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(n.p,{children:"The application uses a custom JWT-based authentication system with:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Token-based authentication"}),"\n",(0,i.jsx)(n.li,{children:"HTTP-only cookies for token storage"}),"\n",(0,i.jsx)(n.li,{children:"Server-side token verification"}),"\n",(0,i.jsx)(n.li,{children:"Middleware for route protection"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"authentication-flow",children:"Authentication Flow"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Registration"}),": User submits name, email, and password"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Login"}),": User submits email and password, receives JWT"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Session Maintenance"}),": JWT is stored in HTTP-only cookies"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Logout"}),": JWT is removed from cookies"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"implementation",children:"Implementation"}),"\n",(0,i.jsx)(n.h3,{id:"backend-routes",children:"Backend Routes"}),"\n",(0,i.jsx)(n.p,{children:"The authentication system is implemented through several API routes:"}),"\n",(0,i.jsx)(n.h4,{id:"register-endpoint",children:"Register Endpoint"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// From app/api/auth/register/route.ts\nexport async function POST(request: Request) {\n  try {\n    const body = await request.json();\n    const { name, email, password } = body;\n\n    // Check if user exists\n    const [existingUser] = await db\n      .select({ id: users.id, name: users.name, email: users.email })\n      .from(users)\n      .where(eq(users.email, email.toLowerCase()));\n\n    if (existingUser) {\n      return NextResponse.json(\n        { message: \"Email already registered\" },\n        { status: 400 }\n      );\n    }\n\n    // Hash password and create user\n    const hashedPassword = await bcrypt.hash(password, 10);\n    const [newUser] = await db\n      .insert(users)\n      .values({\n        name,\n        email: email.toLowerCase(),\n        password: hashedPassword,\n      })\n      .returning({\n        id: users.id,\n        email: users.email,\n        name: users.name,\n      });\n\n    // Create JWT token\n    const token = await createToken({\n      id: newUser.id,\n      email: newUser.email,\n      name: newUser.name,\n    });\n\n    // Set cookie\n    (await cookies()).set('token', token, {\n      httpOnly: true,\n      secure: process.env.NODE_ENV === 'production',\n      sameSite: 'lax',\n      maxAge: 12 * 60 * 60 * 24 * 1000, // 12 days\n      path: '/',\n    });\n    \n    return NextResponse.json({\n      user: newUser,\n      token,\n    }, { status: 201 });\n  } catch (error: unknown) {\n    console.error('Register failed:', error);\n    return NextResponse.json(\n      { message: error || \"Internal server error\" },\n      { status: 500 }\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"login-endpoint",children:"Login Endpoint"}),"\n",(0,i.jsx)(n.p,{children:"Similar to the register endpoint, but verifies credentials against the database."}),"\n",(0,i.jsx)(n.h4,{id:"check-auth-endpoint",children:"Check Auth Endpoint"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// From app/api/auth/checkAuth/route.ts\nexport async function GET(request: NextRequest) {\n  try {\n    const token = request.cookies.get('token')?.value;\n    if (!token) {\n      return NextResponse.json({ user: null, token: null });\n    }\n\n    const payload = await verifyToken(token);\n    if (!payload || !payload.id) {\n      return NextResponse.json({ user: null, token: null });\n    }\n\n    // Find user\n    const [user] = await db\n      .select({\n        id: users.id,\n        email: users.email,\n        name: users.name,\n      })\n      .from(users)\n      .where(eq(users.id, sql.raw(`'${payload.id}'::uuid`)));\n\n    if (!user) {\n      return NextResponse.json({ user: null, token: null });\n    }\n\n    return NextResponse.json({\n      user,\n      token\n    });\n  } catch (error: unknown) {\n    console.error('Auth check failed:', error);\n    return NextResponse.json(\n      { message: \"Auth check failed\" },\n      { status: 500 }\n    );\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"frontend-state-management",children:"Frontend State Management"}),"\n",(0,i.jsx)(n.p,{children:"The authentication state is managed using Zustand:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:'// From lib/store/auth-store.ts (partial)\nexport const useAuthStore = create<AuthState>()(\n  persist(\n    (set) => ({\n      // State properties...\n      \n      login: async (email, password) => {\n        set({ isLoading: true, error: null });\n        \n        try {\n          const res = await fetch("/api/auth/login", {\n            method: "POST",\n            headers: { "Content-Type": "application/json" },\n            body: JSON.stringify({ email, password }),\n            credentials: \'include\'\n          });\n          \n          const data = await res.json();\n          \n          if (!res.ok) throw new Error(data.message || "Login failed");\n          \n          set({ user: data.user, token: data.token });\n          toast.success("Login successful");\n          return data;\n        } catch (error: unknown) {\n          console.error(\'Login failed:\', error);\n          set({ user: null, token: null  });\n          toast.error("Login failed" );\n          throw error;\n        } finally {\n          set({ isLoading: false });\n        }\n      },\n\n      // Other methods...\n    }),\n    {\n      name: \'auth-storage\',\n      partialize: (state) => ({\n        user: state.user,\n        token: state.token \n      })\n    }\n  )\n);\n'})}),"\n",(0,i.jsx)(n.h2,{id:"route-protection",children:"Route Protection"}),"\n",(0,i.jsx)(n.p,{children:"Protected routes are handled using Next.js middleware:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// From middleware.ts\nimport { NextResponse } from 'next/server';\nimport type { NextRequest } from 'next/server';\nimport { verifyToken } from '@/lib/utils/auth';\n\nexport async function middleware(request: NextRequest) {\n  // Implementation...\n}\n\n// Protected routes\nexport const config = {\n  matcher: ['/auth/:path*'],\n};\n"})}),"\n",(0,i.jsx)(n.h2,{id:"security-considerations",children:"Security Considerations"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Passwords are hashed using bcrypt"}),"\n",(0,i.jsx)(n.li,{children:"JWT tokens are stored in HTTP-only cookies"}),"\n",(0,i.jsx)(n.li,{children:"CSRF protection via SameSite cookie attribute"}),"\n",(0,i.jsx)(n.li,{children:"Token expiration is enforced to 12 days"}),"\n",(0,i.jsx)(n.li,{children:"Environment variables are used for sensitive information"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["This is optional for now, ",(0,i.jsx)(n.strong,{children:"users do not need to authenticate"})," to use the application."]})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const i={},r=s.createContext(i);function o(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);