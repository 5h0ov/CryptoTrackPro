"use strict";(self.webpackChunkcrypto_tracker=self.webpackChunkcrypto_tracker||[]).push([[8601],{6185:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>r,toc:()=>l});const r=JSON.parse('{"id":"api-integration","title":"API Integration","description":"This document explains how CryptoTrackPro integrates with external APIs and handles data fetching.","source":"@site/docs/api-integration.md","sourceDirName":".","slug":"/api-integration","permalink":"/CryptoTrackPro/docs/api-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/your-github-user/crypto-tracker/edit/main/docs-site/docs/api-integration.md","tags":[],"version":"current","frontMatter":{"id":"api-integration","title":"API Integration","sidebar_label":"API Integration"},"sidebar":"Sidebar","previous":{"title":"Project Structure","permalink":"/CryptoTrackPro/docs/project-structure"},"next":{"title":"State Management","permalink":"/CryptoTrackPro/docs/state-management"}}');var i=t(4848),a=t(8453);const s={id:"api-integration",title:"API Integration",sidebar_label:"API Integration"},c="API Integration",o={},l=[{value:"CoinCap API Integration",id:"coincap-api-integration",level:2},{value:"API Client Implementation",id:"api-client-implementation",level:3},{value:"Frontend API Client",id:"frontend-api-client",level:4},{value:"Backend API Route Handler",id:"backend-api-route-handler",level:4},{value:"Security Benefits",id:"security-benefits",level:3},{value:"Data Fetching Strategy",id:"data-fetching-strategy",level:2},{value:"Real-time Updates",id:"real-time-updates",level:3},{value:"Authentication API",id:"authentication-api",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"api-integration",children:"API Integration"})}),"\n",(0,i.jsx)(n.p,{children:"This document explains how CryptoTrackPro integrates with external APIs and handles data fetching."}),"\n",(0,i.jsx)(n.h2,{id:"coincap-api-integration",children:"CoinCap API Integration"}),"\n",(0,i.jsxs)(n.p,{children:["The application uses the ",(0,i.jsx)(n.a,{href:"https://docs.coincap.io/",children:"CoinCap API"})," to fetch real-time cryptocurrency data."]}),"\n",(0,i.jsx)(n.h3,{id:"api-client-implementation",children:"API Client Implementation"}),"\n",(0,i.jsx)(n.p,{children:"The API client follows a secure architecture pattern where frontend components call our own API endpoints, which then interface with external services."}),"\n",(0,i.jsx)(n.h4,{id:"frontend-api-client",children:"Frontend API Client"}),"\n",(0,i.jsxs)(n.p,{children:["The frontend API client is implemented in ",(0,i.jsx)(n.code,{children:"lib/utils/coincap.ts"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Cryptocurrency } from \"../types/schema\";\n\nexport interface CryptocurrencyResponse {\n  data: Cryptocurrency[];\n  timestamp: number;\n}\n\nexport async function fetchCryptocurrencies(): Promise<CryptocurrencyResponse> {\n  const response = await fetch('/api/cryptocurrencies');\n  \n  if (!response.ok) {\n    throw new Error('Failed to fetch cryptocurrency data');\n  }\n  \n  return response.json();\n}\n\n// Type definition for cryptocurrency data\nexport interface Cryptocurrency {\n  id: string;\n  rank: string;\n  symbol: string;\n  name: string;\n  supply: string;\n  maxSupply: string;\n  marketCapUsd: string;\n  volumeUsd24Hr: string;\n  priceUsd: string;\n  changePercent24Hr: string;\n  vwap24Hr: string;\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"backend-api-route-handler",children:"Backend API Route Handler"}),"\n",(0,i.jsxs)(n.p,{children:["The API route handler in ",(0,i.jsx)(n.code,{children:"app/api/cryptocurrencies/route.ts"})," manages the actual communication with the CoinCap API:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { NextResponse } from 'next/server';\n\nexport async function GET() {\n  try {\n    const apiKey = process.env.COINCAP_API_KEY;\n    \n    // Excluded limit and let it be default offered by CoinCap (100)\n    const response = await fetch('https://api.coincap.io/v2/assets', {\n      headers: {\n        'Authorization': `Bearer ${apiKey}`\n      },\n      // Ensured fresh data is sent to the client always\n      cache: 'no-store',\n      next: { revalidate: 0 }\n    });\n    \n    if (!response.ok) {\n      throw new Error('Failed to fetch cryptocurrency data');\n    }\n    \n    const data = await response.json();\n    return NextResponse.json(data);\n  } catch (error) {\n    return NextResponse.json({ error: (error as Error).message }, { status: 500 });\n  }\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"security-benefits",children:"Security Benefits"}),"\n",(0,i.jsx)(n.p,{children:"This architecture provides several security and performance advantages:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"API Key Protection"}),": API keys are stored as environment variables on the server and never exposed to the client"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rate Limiting Control"}),": All client requests are funneled through the API, allowing better control of external API quota usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response Transformation"}),": The server can transform, filter, or enhance API responses before sending to the client"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Centralized error handling for external API issues"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data-fetching-strategy",children:"Data Fetching Strategy"}),"\n",(0,i.jsx)(n.p,{children:"The application uses React Query to manage server state and data fetching:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// From app/dashboard/page.tsx\nconst { \n  data, \n  isLoading, \n  isError, \n  error, \n  refetch, \n  isFetching,\n  dataUpdatedAt\n} = useQuery({\n  queryKey: ['cryptocurrencies'],\n  queryFn: fetchCryptocurrencies,\n  refetchInterval: 3000, // Auto-refresh every 3 seconds\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"real-time-updates",children:"Real-time Updates"}),"\n",(0,i.jsx)(n.p,{children:"Due to the limitations of Free Public APIs, real-time updates have been achieved through:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Short polling intervals (every 3 seconds)"}),"\n",(0,i.jsx)(n.li,{children:"Visual indicators for price changes"}),"\n",(0,i.jsx)(n.li,{children:"Optimized re-rendering with React's useEffect"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// From app/dashboard/page.tsx\nuseEffect(() => {\n  if (data?.data) {\n    const newChanges: string[] = [];\n    const newPulseMap: Record<string, 'increase' | 'decrease' | null> = {};\n    \n    // Check for price changes and determine direction\n    data.data.forEach((crypto: Cryptocurrency) => {\n      const prevPrice = previousPrices[crypto.id];\n      \n      if (prevPrice !== undefined) {\n        const currentPrice = parseFloat(crypto.priceUsd);\n        const previousPrice = parseFloat(prevPrice);\n        \n        // Only detect significant changes to avoid floating point issues\n        if (Math.abs(currentPrice - previousPrice) > 0.0000001) {\n          newChanges.push(crypto.id);\n          newPulseMap[crypto.id] = currentPrice > previousPrice ? 'increase' : 'decrease';\n        }\n      }\n    });\n    \n    // Update state with new information\n    // ...\n  }\n}, [data]);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"authentication-api",children:"Authentication API"}),"\n",(0,i.jsx)(n.p,{children:"The application implements its own authentication API endpoints:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/register"}),": User registration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/login"}),": User login"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/logout"}),": User logout"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/checkAuth"}),": Authentication status check"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These endpoints use JWT tokens for authentication, stored in HTTP-only cookies."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var r=t(6540);const i={},a=r.createContext(i);function s(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);