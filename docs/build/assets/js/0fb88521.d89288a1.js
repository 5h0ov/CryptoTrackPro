"use strict";(self.webpackChunkcrypto_tracker=self.webpackChunkcrypto_tracker||[]).push([[8601],{6185:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>c,default:()=>p,frontMatter:()=>s,metadata:()=>t,toc:()=>l});const t=JSON.parse('{"id":"api-integration","title":"API Integration","description":"This document explains how CryptoTrackPro integrates with external APIs and handles data fetching.","source":"@site/docs/api-integration.md","sourceDirName":".","slug":"/api-integration","permalink":"/docs/api-integration","draft":false,"unlisted":false,"editUrl":"https://github.com/your-github-user/crypto-tracker/edit/main/docs-site/docs/api-integration.md","tags":[],"version":"current","frontMatter":{"id":"api-integration","title":"API Integration","sidebar_label":"API Integration"},"sidebar":"Sidebar","previous":{"title":"Project Structure","permalink":"/docs/project-structure"},"next":{"title":"State Management","permalink":"/docs/state-management"}}');var i=r(4848),a=r(8453);const s={id:"api-integration",title:"API Integration",sidebar_label:"API Integration"},c="API Integration",o={},l=[{value:"CoinCap API Integration",id:"coincap-api-integration",level:2},{value:"API Client Implementation",id:"api-client-implementation",level:3},{value:"Frontend API Client",id:"frontend-api-client",level:4},{value:"Backend API Route Handler",id:"backend-api-route-handler",level:4},{value:"Security Benefits",id:"security-benefits",level:3},{value:"Data Fetching Strategy",id:"data-fetching-strategy",level:2},{value:"Real-time Updates",id:"real-time-updates",level:3},{value:"Authentication API",id:"authentication-api",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"api-integration",children:"API Integration"})}),"\n",(0,i.jsx)(n.p,{children:"This document explains how CryptoTrackPro integrates with external APIs and handles data fetching."}),"\n",(0,i.jsx)(n.h2,{id:"coincap-api-integration",children:"CoinCap API Integration"}),"\n",(0,i.jsxs)(n.p,{children:["The application uses the ",(0,i.jsx)(n.a,{href:"https://docs.coincap.io/",children:"CoinCap API"})," to fetch real-time cryptocurrency data."]}),"\n",(0,i.jsx)(n.h3,{id:"api-client-implementation",children:"API Client Implementation"}),"\n",(0,i.jsx)(n.p,{children:"The API client follows a secure architecture pattern where frontend components call our own API endpoints, which then interface with external services."}),"\n",(0,i.jsx)(n.h4,{id:"frontend-api-client",children:"Frontend API Client"}),"\n",(0,i.jsxs)(n.p,{children:["The frontend API client is implemented in ",(0,i.jsx)(n.code,{children:"lib/utils/coincap.ts"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { Cryptocurrency } from \"../types/schema\";\r\n\r\nexport interface CryptocurrencyResponse {\r\n  data: Cryptocurrency[];\r\n  timestamp: number;\r\n}\r\n\r\nexport async function fetchCryptocurrencies(): Promise<CryptocurrencyResponse> {\r\n  const response = await fetch('/api/cryptocurrencies');\r\n  \r\n  if (!response.ok) {\r\n    throw new Error('Failed to fetch cryptocurrency data');\r\n  }\r\n  \r\n  return response.json();\r\n}\r\n\r\n// Type definition for cryptocurrency data\r\nexport interface Cryptocurrency {\r\n  id: string;\r\n  rank: string;\r\n  symbol: string;\r\n  name: string;\r\n  supply: string;\r\n  maxSupply: string;\r\n  marketCapUsd: string;\r\n  volumeUsd24Hr: string;\r\n  priceUsd: string;\r\n  changePercent24Hr: string;\r\n  vwap24Hr: string;\r\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"backend-api-route-handler",children:"Backend API Route Handler"}),"\n",(0,i.jsxs)(n.p,{children:["The API route handler in ",(0,i.jsx)(n.code,{children:"app/api/cryptocurrencies/route.ts"})," manages the actual communication with the CoinCap API:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"import { NextResponse } from 'next/server';\r\n\r\nexport async function GET() {\r\n  try {\r\n    const apiKey = process.env.COINCAP_API_KEY;\r\n    \r\n    // Excluded limit and let it be default offered by CoinCap (100)\r\n    const response = await fetch('https://api.coincap.io/v2/assets', {\r\n      headers: {\r\n        'Authorization': `Bearer ${apiKey}`\r\n      },\r\n      // Ensured fresh data is sent to the client always\r\n      cache: 'no-store',\r\n      next: { revalidate: 0 }\r\n    });\r\n    \r\n    if (!response.ok) {\r\n      throw new Error('Failed to fetch cryptocurrency data');\r\n    }\r\n    \r\n    const data = await response.json();\r\n    return NextResponse.json(data);\r\n  } catch (error) {\r\n    return NextResponse.json({ error: (error as Error).message }, { status: 500 });\r\n  }\r\n}\n"})}),"\n",(0,i.jsx)(n.h3,{id:"security-benefits",children:"Security Benefits"}),"\n",(0,i.jsx)(n.p,{children:"This architecture provides several security and performance advantages:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"API Key Protection"}),": API keys are stored as environment variables on the server and never exposed to the client"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Rate Limiting Control"}),": All client requests are funneled through the API, allowing better control of external API quota usage"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Response Transformation"}),": The server can transform, filter, or enhance API responses before sending to the client"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Error Handling"}),": Centralized error handling for external API issues"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"data-fetching-strategy",children:"Data Fetching Strategy"}),"\n",(0,i.jsx)(n.p,{children:"The application uses React Query to manage server state and data fetching:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// From app/dashboard/page.tsx\r\nconst { \r\n  data, \r\n  isLoading, \r\n  isError, \r\n  error, \r\n  refetch, \r\n  isFetching,\r\n  dataUpdatedAt\r\n} = useQuery({\r\n  queryKey: ['cryptocurrencies'],\r\n  queryFn: fetchCryptocurrencies,\r\n  refetchInterval: 3000, // Auto-refresh every 3 seconds\r\n});\n"})}),"\n",(0,i.jsx)(n.h3,{id:"real-time-updates",children:"Real-time Updates"}),"\n",(0,i.jsx)(n.p,{children:"Due to the limitations of Free Public APIs, real-time updates have been achieved through:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Short polling intervals (every 3 seconds)"}),"\n",(0,i.jsx)(n.li,{children:"Visual indicators for price changes"}),"\n",(0,i.jsx)(n.li,{children:"Optimized re-rendering with React's useEffect"}),"\n"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-typescript",children:"// From app/dashboard/page.tsx\r\nuseEffect(() => {\r\n  if (data?.data) {\r\n    const newChanges: string[] = [];\r\n    const newPulseMap: Record<string, 'increase' | 'decrease' | null> = {};\r\n    \r\n    // Check for price changes and determine direction\r\n    data.data.forEach((crypto: Cryptocurrency) => {\r\n      const prevPrice = previousPrices[crypto.id];\r\n      \r\n      if (prevPrice !== undefined) {\r\n        const currentPrice = parseFloat(crypto.priceUsd);\r\n        const previousPrice = parseFloat(prevPrice);\r\n        \r\n        // Only detect significant changes to avoid floating point issues\r\n        if (Math.abs(currentPrice - previousPrice) > 0.0000001) {\r\n          newChanges.push(crypto.id);\r\n          newPulseMap[crypto.id] = currentPrice > previousPrice ? 'increase' : 'decrease';\r\n        }\r\n      }\r\n    });\r\n    \r\n    // Update state with new information\r\n    // ...\r\n  }\r\n}, [data]);\n"})}),"\n",(0,i.jsx)(n.h2,{id:"authentication-api",children:"Authentication API"}),"\n",(0,i.jsx)(n.p,{children:"The application implements its own authentication API endpoints:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/register"}),": User registration"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/login"}),": User login"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/logout"}),": User logout"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"/api/auth/checkAuth"}),": Authentication status check"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These endpoints use JWT tokens for authentication, stored in HTTP-only cookies."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>s,x:()=>c});var t=r(6540);const i={},a=t.createContext(i);function s(e){const n=t.useContext(a);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);